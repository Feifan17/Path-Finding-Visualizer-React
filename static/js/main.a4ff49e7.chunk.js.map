{"version":3,"sources":["assets/images/logo.png","Header/Header.js","Layout/Layout.js","Visualizer/Node/Node.js","Visualizer/Menu/Menu.js","Visualizer/GridControls/GridControls.js","algorithms/dijkstra.js","algorithms/dfs.js","algorithms/bfs.js","algorithms/utility.js","Visualizer/Visualizer.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Header","props","Navbar","bg","variant","Brand","href","alt","src","logo","width","height","className","Layout","children","Node","row","col","isStart","isFinish","isWall","extraClassName","classes","push","id","join","onClick","toggle","useStyles","makeStyles","theme","formControl","margin","spacing","minWidth","selectEmpty","marginTop","Menu","useState","selectedAlgorithm","setAlgo","Card","CardContent","Typography","Row","FormControl","Select","disabled","isAnimationFinished","defaultValue","onChange","reset","event","target","value","bind","this","MenuItem","Button","color","start","GridControls","component","RadioGroup","aria-label","name","currentSymbol","changeSymbol","FormControlLabel","control","Radio","label","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","updateUnvisitedNeighbors","node","grid","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","length","filter","isVisited","getAllNodes","nodes","dijkstra","startNode","finishNode","console","log","visitedNodesInOrder","closestNode","shift","Infinity","dfs","unshift","currentNode","onShortestPath","i","bfs","getNodesInShortestPathOrder","nodesInShortestPathOrder","Visualizer","getInitialGrid","currentRow","startAnimation","state","setState","visualizeDijkstra","visualizeDFS","visualizeBFS","resetGrid","newGrid","changeSymbolHandler","selectedSymbol","nodeToggleHandler","startNodeHandler","finishNodeHandler","wallNodeHandler","newRow","newCol","forceUpdate","animateDijkstra","setTimeout","animateShortestPath","document","getElementById","animateDFS","animateBFS","initialGrid","Container","Col","sm","map","rowIndex","key","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.a4ff49e7.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACHklEQVRYhcXXPUjDQBQH8L/VVhQVwc3RtYLdxclBcK2Cg6AUOomtYAe/KoLiYOniYMHBzckOxUEcBIc6qp1bOqhgbQURPwZFvL/DVcKZFFK8JMNbksd7v1wuLxxI+EgkSTyQECTocIh6rzUSLag3d7ppo1gBiZqHgHt42JwkhNcANg14ewNPTsCdHXBpCVxeBlMp8PgYfHpyEFAqgZEI2NkJAtbh94OTk2CxqBEgBLi9DQYCjRv/jY4OMJvVBNjcNAqPjoJ7e+DlJVipgNUqWCiA6TTY368iAgGZ9y/AywvY3Q1OTMhGJPj1BWYy4OOjmlurgQMDKmJsTPMmFAKcnZXFz8/N9w8OVEBbG/j+rhGQyxnFLy7M9wsF834olTQBhAAHB43C5bI55/raDLi91QQ4OzOKtrfLvfA3J5tVm/f2gt/fmgDT00bhUMg6Z2ZGBUSjmjbhxwfY02MUjkSsV6i11cjp6gJvbjQBTk/VJ8tk5PVqVY7luTl1UPl84NGRvZW1BVhYUAFXV2AyaT0F+/rk12L31doCDA2pE+7zE7y7A+fn5XQcHgbDYXB3F3x+tt/cFuD1VS7pLyAYbK7BvwH5vLrEIyMuA/b3VcD4uMuA9XUVMDXlMiAWa364aAXE4ypgcdFlwMaGCjg8dBlQLoOJBLi1Zf0LdhzgdIDunAcbhQDlQdErQAWUp1SvAKugPJ6vkai49DpEvdcKiZYf/HPRuvBDD3wAAAAASUVORK5CYII=\"","import React from \"react\";\n// React bootstrap.\nimport Navbar from \"react-bootstrap/Navbar\";\n// Image assets.\nimport logo from \"../assets/images/logo.png\";\n\nfunction Header(props) {\n  return (\n    <Navbar bg=\"dark\" variant=\"dark\">\n      <Navbar.Brand href=\"\">\n        <img\n          alt=\"Path Finding Visualizer\"\n          src={logo}\n          width=\"30\"\n          height=\"30\"\n          className=\"d-inline-block align-top\"\n        />{\" \"}\n        Path Finding Visualizer\n      </Navbar.Brand>\n    </Navbar>\n  );\n}\n\nexport default Header;\n","import React, { Fragment } from \"react\";\nimport Header from \"../Header/Header\";\n\nfunction Layout(props) {\n  return (\n    <Fragment>\n      <Header></Header>\n      {props.children}\n    </Fragment>\n  );\n}\n\nexport default Layout;\n","import React from \"react\";\nimport \"./Node.css\";\n\nfunction Node(props) {\n  const row = props.row;\n  const col = props.col;\n  const isStart = props.isStart;\n  const isFinish = props.isFinish;\n  const isWall = props.isWall;\n\n  const extraClassName = isFinish\n    ? \"nodeFinish\"\n    : isStart\n    ? \"nodeStart\"\n    : isWall\n    ? \"nodeWall\"\n    : \"\";\n\n  const classes = [];\n  classes.push(extraClassName);\n  classes.push(\"node\");\n\n  return (\n    <div\n      id={`${row}-${col}`}\n      className={classes.join(\" \")}\n      onClick={props.toggle}\n    ></div>\n  );\n}\n\nexport default Node;\n","import React, { useState } from \"react\";\n// React Bootstrap.\nimport Row from \"react-bootstrap/Row\";\n// Material UI.\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport Card from \"@material-ui/core/Card\";\nimport CardContent from \"@material-ui/core/CardContent\";\nimport Typography from \"@material-ui/core/Typography\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport Select from \"@material-ui/core/Select\";\nimport Button from \"@material-ui/core/Button\";\n\nconst useStyles = makeStyles(theme => ({\n  formControl: {\n    margin: theme.spacing(1),\n    minWidth: 120\n  },\n  selectEmpty: {\n    marginTop: theme.spacing(2)\n  }\n}));\n\nfunction Menu(props) {\n  // Manage the selected algorithm.\n  const [selectedAlgorithm, setAlgo] = useState(\"dijkstra\");\n\n  // When the selected algorithm changed, clear the board and update the state.\n  const onChangeAlgorithm = (reset, event) => {\n    setAlgo(event.target.value);\n    reset();\n  };\n\n  const classes = useStyles();\n  return (\n    <Card className=\"text-center mx-auto w-75\">\n      <CardContent>\n        <Typography className=\"font-weight-bold\">Menu</Typography>\n        <Row className=\"d-flex justify-content-center my-3\">\n          <FormControl className={classes.formControl}>\n            <Select\n              disabled={!props.isAnimationFinished}\n              defaultValue={\"dijkstra\"}\n              onChange={onChangeAlgorithm.bind(this, props.reset)}\n            >\n              <MenuItem value={\"dijkstra\"}>Dijkstra's Algorithm</MenuItem>\n              <MenuItem value={\"dfs\"}>Depth-first Search</MenuItem>\n              <MenuItem value={\"bfs\"}>Breadth-first Search</MenuItem>\n            </Select>\n          </FormControl>\n        </Row>\n        <Row className=\"d-flex justify-content-center my-3\">\n          <Button\n            disabled={!props.isAnimationFinished}\n            className=\"w-50\"\n            variant=\"contained\"\n            color=\"primary\"\n            onClick={props.reset}\n          >\n            Reset\n          </Button>\n        </Row>\n        <Row className=\"d-flex justify-content-center my-3\">\n          <Button\n            disabled={!props.isAnimationFinished}\n            className=\"w-50\"\n            variant=\"contained\"\n            color=\"primary\"\n            onClick={props.start.bind(this, selectedAlgorithm)}\n          >\n            Start\n          </Button>\n        </Row>\n      </CardContent>\n    </Card>\n  );\n}\n\nexport default Menu;\n","import React from \"react\";\n// React Bootstrap.\nimport Row from \"react-bootstrap/Row\";\n// Material UI.\nimport Card from \"@material-ui/core/Card\";\nimport CardContent from \"@material-ui/core/CardContent\";\nimport Typography from \"@material-ui/core/Typography\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport RadioGroup from \"@material-ui/core/RadioGroup\";\nimport FormControlLabel from \"@material-ui/core/FormControlLabel\";\nimport Radio from \"@material-ui/core/Radio\";\n\nfunction GridControls(props) {\n  return (\n    <Card className=\"text-center mx-auto w-75 my-3\">\n      <CardContent>\n        <Typography className=\"font-weight-bold\">Grid Controls</Typography>\n        <Row className=\"d-flex justify-content-center my-3\">\n          <FormControl component=\"fieldset\">\n            <RadioGroup\n              aria-label=\"symbols\"\n              name=\"symbols\"\n              value={props.currentSymbol}\n              onChange={props.changeSymbol}\n            >\n              <FormControlLabel\n                value=\"start\"\n                control={<Radio />}\n                label=\"Start Node\"\n              />\n\n              <FormControlLabel\n                value=\"finish\"\n                control={<Radio />}\n                label=\"Finish Node\"\n              />\n              <FormControlLabel\n                value=\"wall\"\n                control={<Radio />}\n                label=\"Wall Node\"\n              />\n            </RadioGroup>\n          </FormControl>\n        </Row>\n      </CardContent>\n    </Card>\n  );\n}\n\nexport default GridControls;\n","// Dijkstra algorithm.\nconst dijkstra = (grid, startNode, finishNode) => {\n  console.log(startNode);\n  console.log(finishNode);\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (unvisitedNodes.length > 0) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    // If we have reached the destination, stop searching.\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n};\n\n// Sort nodes by distance (nodes with shorter distances come first).\nconst sortNodesByDistance = unvisitedNodes => {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n};\n\n// Updated the distances of all unvisited neighbor nodes.\nconst updateUnvisitedNeighbors = (node, grid) => {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n};\n\n// Get all unvisited neighbors of the current node.\nconst getUnvisitedNeighbors = (node, grid) => {\n  const neighbors = [];\n  const row = node.row;\n  const col = node.col;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  // filter out nodes that have already been visited.\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\n// Get all nodes from the grid.\nconst getAllNodes = grid => {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nexport default dijkstra;\n","const dfs = (grid, startNode, finishNode) => {\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = [];\n  unvisitedNodes.unshift(startNode);\n  while (unvisitedNodes.length > 0) {\n    let currentNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (currentNode.isWall) continue;\n    currentNode.isVisited = true;\n    currentNode.onShortestPath = true;\n    visitedNodesInOrder.push(currentNode);\n    // If we have reached the destination, stop searching.\n    if (currentNode === finishNode) return visitedNodesInOrder;\n\n    const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n    for (let i = unvisitedNeighbors.length - 1; i >= 0; i--) {\n      unvisitedNodes.unshift(unvisitedNeighbors[i]);\n    }\n  }\n  return visitedNodesInOrder;\n};\n\n// Get all unvisited neighbors of the current node.\nconst getUnvisitedNeighbors = (node, grid) => {\n  const neighbors = [];\n  const row = node.row;\n  const col = node.col;\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n\n  // filter out nodes that have already been visited.\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\nexport default dfs;\n","const bfs = (grid, startNode, finishNode) => {\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = [];\n  unvisitedNodes.push(startNode);\n  while (unvisitedNodes.length > 0) {\n    let currentNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (currentNode.isWall) continue;\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n    // If we have reached the destination, stop searching.\n    if (currentNode === finishNode) return visitedNodesInOrder;\n    const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n    for (let neighbor of unvisitedNeighbors) {\n      unvisitedNodes.push(neighbor);\n      neighbor.isVisited = true;\n      neighbor.previousNode = currentNode;\n    }\n  }\n  return visitedNodesInOrder;\n};\n\n// Get all unvisited neighbors of the current node.\nconst getUnvisitedNeighbors = (node, grid) => {\n  const neighbors = [];\n  const row = node.row;\n  const col = node.col;\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n\n  // filter out nodes that have already been visited.\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\nexport default bfs;\n","// Backtracks from the finish node to find the shortest path.\nconst getNodesInShortestPathOrder = finishNode => {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode.onShortestPath = true;\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n};\n\nexport default getNodesInShortestPathOrder;\n","import React, { Component } from \"react\";\n// Custom components.\nimport Node from \"./Node/Node\";\nimport Menu from \"./Menu/Menu\";\nimport GridControls from \"./GridControls/GridControls\";\n//  Path finding algorithms.\nimport dijkstra from \"../algorithms/dijkstra\";\nimport dfs from \"../algorithms/dfs\";\nimport bfs from \"../algorithms/bfs\";\nimport getNodesInShortestPathOrder from \"../algorithms/utility\";\n// React Bootstrap.\nimport Row from \"react-bootstrap/Row\";\nimport Col from \"react-bootstrap/Col\";\nimport Container from \"react-bootstrap/Container\";\n\nclass Visualizer extends Component {\n  // Constructor method.\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n      startNode: {\n        row: -1,\n        col: -1\n      },\n      finishNode: {\n        row: -1,\n        col: -1\n      },\n      isAnimationFinished: true,\n      selectedSymbol: \"start\"\n    };\n  }\n\n  // Initialize the grid after the view is rendered.\n  componentDidMount() {\n    const initialGrid = this.getInitialGrid();\n    this.setState({\n      grid: initialGrid\n    });\n  }\n\n  // Generate the initial grid.\n  getInitialGrid = () => {\n    const grid = [];\n    for (let row = 0; row < 30; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 30; col++) {\n        currentRow.push({\n          row: row,\n          col: col,\n          isStart: false,\n          isFinish: false,\n          distance: Infinity,\n          isVisited: false,\n          isWall: false,\n          previousNode: null,\n          onShortestPath: false\n        });\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n\n  // Start the animation.\n  startAnimation = selectedAlgorithm => {\n    // Ensure the start node and the finish node are in the grid.\n    if (\n      this.state.startNode.row === -1 ||\n      this.state.startNode.col === -1 ||\n      this.state.finishNode.row === -1 ||\n      this.state.finishNode.col === -1\n    )\n      return;\n    this.setState({\n      isAnimationFinished: false\n    });\n    switch (selectedAlgorithm) {\n      case \"dijkstra\":\n        this.visualizeDijkstra();\n        break;\n      case \"dfs\":\n        this.visualizeDFS();\n        break;\n      case \"bfs\":\n        this.visualizeBFS();\n        break;\n      default:\n        break;\n    }\n  };\n\n  // Reset the grid.\n  resetGrid = () => {\n    const newGrid = this.getInitialGrid();\n    this.setState(\n      {\n        grid: []\n      },\n      () => {\n        this.setState({\n          grid: newGrid,\n          startNode: {\n            row: -1,\n            col: -1\n          },\n          finishNode: {\n            row: -1,\n            col: -1\n          }\n        });\n      }\n    );\n  };\n\n  // Update the selected symbol.\n  changeSymbolHandler = event => {\n    this.setState({\n      selectedSymbol: event.target.value\n    });\n  };\n\n  // Handle each node differently based on the selected symbol.\n  nodeToggleHandler = (row, col) => {\n    // The grid should be untouchable during the animation.\n    if (!this.state.isAnimationFinished) return;\n    switch (this.state.selectedSymbol) {\n      case \"start\":\n        this.startNodeHandler(row, col);\n        break;\n      case \"finish\":\n        this.finishNodeHandler(row, col);\n        break;\n      case \"wall\":\n        this.wallNodeHandler(row, col);\n        break;\n      default:\n        break;\n    }\n  };\n\n  // Start node toggle handler.\n  startNodeHandler = (newRow, newCol) => {\n    // If the position is unchanged, return.\n    if (\n      this.state.startNode.row === newRow &&\n      this.state.startNode.col === newCol\n    )\n      return;\n    // Set the old start node's isStart property back to false.\n    if (this.state.startNode.row !== -1 && this.state.startNode.col !== -1) {\n      const oldStart = this.state.grid[this.state.startNode.row][\n        this.state.startNode.col\n      ];\n      oldStart.isStart = false;\n    }\n    // Set the new start node.\n    const newStart = this.state.grid[newRow][newCol];\n    newStart.isStart = true;\n    this.setState({\n      startNode: {\n        row: newRow,\n        col: newCol\n      }\n    });\n  };\n\n  // Finish node toggle handler.\n  finishNodeHandler = (newRow, newCol) => {\n    // If the position is unchanged, return.\n    if (\n      this.state.finishNode.row === newRow &&\n      this.state.finishNode.col === newCol\n    )\n      return;\n    // Set the old finish node's isStart property back to false.\n    if (this.state.finishNode.row !== -1 && this.state.finishNode.col !== -1) {\n      const oldFinish = this.state.grid[this.state.finishNode.row][\n        this.state.finishNode.col\n      ];\n      oldFinish.isFinish = false;\n    }\n    // Set the new finish node.\n    const oldFinish = this.state.grid[newRow][newCol];\n    oldFinish.isFinish = true;\n    this.setState({\n      finishNode: {\n        row: newRow,\n        col: newCol\n      }\n    });\n  };\n\n  // Wall node toggle handler.\n  wallNodeHandler = (newRow, newCol) => {\n    const node = this.state.grid[newRow][newCol];\n    if (node.isWall) {\n      node.isWall = false;\n    } else {\n      node.isWall = true;\n    }\n    this.forceUpdate();\n  };\n\n  // Animate Dijkstra's algorithm.\n  animateDijkstra = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        // The start node and the finish node are in the path,\n        // but they should remain the same styling just for the\n        // path to be clear.\n        if (!node.isStart && !node.isFinish) {\n          document.getElementById(`${node.row}-${node.col}`).className =\n            \"node nodeVisited\";\n        }\n      }, 10 * i);\n    }\n  };\n\n  // Wrapper method for animateDijkstra().\n  visualizeDijkstra = () => {\n    const grid = this.state.grid;\n    const startNode = grid[this.state.startNode.row][this.state.startNode.col];\n    const finishNode =\n      grid[this.state.finishNode.row][this.state.finishNode.col];\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  // Animate Depth-first Search.\n  animateDFS = visitedNodesInOrder => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      // Animate the shortestPath.\n      // DFS doesn't guarantee the shortest path,\n      // but here we call the same method just for animation convenience.\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(visitedNodesInOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        // The start node and the finish node are in the path,\n        // but they should remain the same styling just for the\n        // path to be clear.\n        if (!node.isStart && !node.isFinish) {\n          document.getElementById(`${node.row}-${node.col}`).className =\n            \"node nodeVisited\";\n        }\n      }, 10 * i);\n    }\n  };\n\n  // Wrapper method for animateDFS().\n  visualizeDFS = () => {\n    const grid = this.state.grid;\n    const startNode = grid[this.state.startNode.row][this.state.startNode.col];\n    const finishNode =\n      grid[this.state.finishNode.row][this.state.finishNode.col];\n    const visitedNodesInOrder = dfs(grid, startNode, finishNode);\n    this.animateDFS(visitedNodesInOrder);\n  };\n\n  // Animate Breadth-first Search.\n  animateBFS = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      // Animate the shortestPath.\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        // The start node and the finish node are in the path,\n        // but they should remain the same styling just for the\n        // path to be clear.\n        if (!node.isStart && !node.isFinish) {\n          document.getElementById(`${node.row}-${node.col}`).className =\n            \"node nodeVisited\";\n        }\n      }, 10 * i);\n    }\n  };\n\n  // Wrapper method for animateBFS().\n  visualizeBFS = () => {\n    const grid = this.state.grid;\n    const startNode = grid[this.state.startNode.row][this.state.startNode.col];\n    const finishNode =\n      grid[this.state.finishNode.row][this.state.finishNode.col];\n    const visitedNodesInOrder = bfs(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateBFS(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  // Animate the shortest path from the start node to the finish node.\n  animateShortestPath = nodesInShortestPathOrder => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        if (!node.isStart && !node.isFinish) {\n          document.getElementById(`${node.row}-${node.col}`).className =\n            \"node nodeShortestPath\";\n        }\n        // Update the state when animation is finished.\n        if (i === nodesInShortestPathOrder.length - 1) {\n          this.setState({\n            isAnimationFinished: true\n          });\n        }\n      }, 50 * i);\n    }\n  };\n\n  render() {\n    return (\n      <Container className=\"d-flex w-100 h-75 mx-auto my-auto\">\n        <Row className=\"d-flex w-100 h-75 mx-auto my-auto\">\n          <Col className=\"mw-75 my-3\" sm={8}>\n            {this.state.grid.map((row, rowIndex) => {\n              return (\n                <Row\n                  key={rowIndex}\n                  className=\"d-flex w-100 justify-content-center mx-auto\"\n                >\n                  {row.map(node => {\n                    return (\n                      <Node\n                        key={`${node.row}-${node.col}`}\n                        row={node.row}\n                        col={node.col}\n                        isStart={\n                          node.row === this.state.startNode.row &&\n                          node.col === this.state.startNode.col\n                        }\n                        isFinish={\n                          node.row === this.state.finishNode.row &&\n                          node.col === this.state.finishNode.col\n                        }\n                        isWall={node.isWall}\n                        toggle={this.nodeToggleHandler.bind(\n                          this,\n                          node.row,\n                          node.col\n                        )}\n                      ></Node>\n                    );\n                  })}\n                </Row>\n              );\n            })}\n          </Col>\n          <Col className=\"mw-25 my-3\" sm={4}>\n            <Menu\n              reset={this.resetGrid}\n              start={this.startAnimation}\n              isAnimationFinished={this.state.isAnimationFinished}\n            ></Menu>\n            <GridControls\n              changeSymbol={this.changeSymbolHandler}\n              currentSymbol={this.state.selectedSymbol}\n            ></GridControls>\n          </Col>\n        </Row>\n      </Container>\n    );\n  }\n}\n\nexport default Visualizer;\n","import React, { Component } from \"react\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport \"./App.css\";\nimport Layout from \"./Layout/Layout\";\nimport Visualizer from \"./Visualizer/Visualizer\";\n\nclass App extends Component {\n  render() {\n    return (\n      <Layout>\n        <Visualizer></Visualizer>\n      </Layout>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}